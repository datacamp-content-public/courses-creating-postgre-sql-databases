---
title: 'Insert title here'
key: 8783137a14e80a186a3ee84c1645f6a0
---

## Defining Numeric Data Columns

```yaml
type: TitleSlide
key: 3f4446f569
```

`@lower_third`
name: Darryl Reeves
title: Assistant Professor, Long Island University - Brooklyn

`@script`
- Now that we have seen how to represent text data in our database, let's move on to the representation of numeric data.

---

## Numeric data with discrete values

```yaml
type: TwoRows
key: 1b35274c09
disable_transition: true
```

`@part1`
```
CREATE TABLE people.employee {
    id serial PRIMARY KEY,
    first_name varchar(50) NOT NULL,
    last_name varchar(50) NOT NULL
} {{1}}
```

`@part2`


`@script`
- Imagine we are creating a database for a local retail clothing store. 
- We will likely be interested in having a representation for the store's employees. 
- We can store details about the store's employees in a table named "employee" as part of a "people" schema. 
- A definition of the table is included here with some basic columns for the employees.
- What if we wanted to also track the number of sales generated by an employee?

---

## Numeric data with discrete values

```yaml
type: TwoRows
key: e3c847c81d
```

`@part1`
```
CREATE TABLE people.employee {
    id serial PRIMARY KEY,
    first_name varchar(50) NOT NULL,
    last_name varchar(50) NOT NULL,
    num_sales integer
}
```{{1}}

`@part2`


`@script`
- This can be done by including a "num underscore sales" column when creating the employee table. 
- We do not anticipate anticipate awarding half of a sale to an employee so a discrete value is appropriate here.

---

## Integer Types

```yaml
type: FullSlide
key: 8a408c6e2f
disable_transition: true
code_zoom: 106
```

`@part1`
| Type | Description | Range |
|---|--------------|---------|
| smallint | small-range integer | -32768 to +32767| {{1}}

`@script`
- PostgreSQL provides other options for representing discrete numerical values. 
- The smallint type can be used for columns needing discrete values in a small range. 
- This is a good type to use if a column only requires relatively small quantities. 
- For instance, if we wanted to store someone's age in whole numbers, a smallint column would suffice.

---

## Integer Types

```yaml
type: FullSlide
key: 3d6ea79ad2
disable_transition: true
```

`@part1`
| Type | Description | Range |
|---|--------------|---------|
| smallint | small-range integer | -32768 to +32767|
| integer | typical choice for integer | -2147483648 to +2147483647         |

`@script`
- We used the integer type previously to represent the number of sales in our employee table. 
- The integer type would also be appropriate for a table column representing the population of large cities given the range of values it can represent.

---

## Integer Types

```yaml
type: FullSlide
key: 38250b57d5
disable_transition: true
```

`@part1`
| Type | Description | Range |
|---|--------------|---------|
| smallint | small-range integer | -32768 to +32767|
| integer | typical choice for integer | -2147483648 to +2147483647         |
| bigint | large-range integer |-9223372036854775808 to 9223372036854775807         |

`@script`
- For columns requiring very large integer values, the bigint type is available. 
- Given the large range of values that are allowed for this type, bigint could be used to represent the number of credit card transactions processed in a year for VISA or MasterCard.

---

## Integer Types

```yaml
type: FullSlide
key: 2e064a254e
disable_transition: false
```

`@part1`
| Type | Description | Range |
|---|--------------|---------|
| smallint | small-range integer | -32768 to +32767|
| integer | typical choice for integer | -2147483648 to +2147483647         |
| bigint | large-range integer |-9223372036854775808 to 9223372036854775807         |
| serial | autoincrementing integer | 1 to 2147483647 |

`@script`
- Serial is a positive integer type that increments by one each time a new record is added to a table. 
-This makes it a good choice for representing primary keys.

---

## Integer Types

```yaml
type: FullSlide
key: 2c9b265cb6
```

`@part1`
| Type | Description | Range |
|---|--------------|---------|
| bigserial | large autoincrementing integer | 1 to 9223372036854775807 |

`@script`
- Finally, the bigserial type has the same properties as the serial type but allows a larger range of values. 
- This would be a good choice for a table tracking NYC subway trips in a given year.

---

## Numeric data with continuous values

```yaml
type: TwoRows
key: 109e2b1f59
disable_transition: true
```

`@part1`
```
CREATE TABLE people.employee {
    id serial PRIMARY KEY,
    first_name varchar(50) NOT NULL,
    last_name varchar(50) NOT NULL,
    num_sales integer NULL
}
``` {{1}}

`@part2`


`@script`
- Floating-point (aka decimal valued) columns are also available in PostgreSQL. 
-Let's revisit the employee table from earlier in this lesson.

---

## Numeric data with continuous values

```yaml
type: TwoRows
key: 30c120cc9c
```

`@part1`
```
CREATE TABLE people.employee {
    id serial PRIMARY KEY,
    first_name varchar(50) NOT NULL,
    last_name varchar(50) NOT NULL,
    num_sales integer NULL,
    salary decimal(6,2) NOT NULL
}
```

`@part2`
*decimal(**precision**, **scale**)* {{2}}

`@script`
- If we wanted to track the salary of each employee, we can use the decimal type to represent salary data in our table. 
- The decimal type can take two arguments: precision and scale.
- Precision is the total number of digits in the number before and after the decimal point. 
- Scale is the number of digits to the right of the decimal point. 
- Here we limit the column entries to 6 digits of precision and 2 digits of scale. 
- This assumes we won't have anyone making $1 million or more at our small shop.

---

## Floating-point Types

```yaml
type: FullSlide
key: b844039e49
disable_transition: true
```

`@part1`
| Type | Description | Range |
|---|--------------|---------|
| decimal (numeric) | user-specified precision | up to 131072 digits before the decimal point; up to 16383 digits after the decimal point |

`@script`
- The decimal and numeric types are interchangeable. 
- They allow for a wide-range of floating-point values to be stored in a table as can be seen based on the range description.

---

## Floating-point Types

```yaml
type: FullSlide
key: 99452923ec
disable_transition: true
```

`@part1`
| Type | Description | Range |
|---|--------------|---------|
| decimal (numeric) | user-specified precision | up to 131072 digits before the decimal point; up to 16383 digits after the decimal point |
| real | variable-precision | 6 decimal digits precision |

`@script`
- The real type guarantees 6 decimals of precision.

---

## Floating-point Types

```yaml
type: FullSlide
key: a4c22ba7c7
```

`@part1`
| Type | Description | Range |
|---|--------------|---------|
| decimal (numeric) | user-specified precision | up to 131072 digits before the decimal point; up to 16383 digits after the decimal point |
| real | variable-precision | 6 decimal digits precision |
| double precision | variable-precision | 15 decimal digits precision |

`@script`
- The double precision type is similar but guarantees 15 digits of precision. 
- Real and double precision are best-suited for columns where it is desirable to reduce storage space and it is ok that the number that is inserted into the database is not exactly equal to the number that is returned by a query.
- Use numeric or decimal in most cases.

---

## Let's practice!

```yaml
type: FinalSlide
key: 6e8f830bb9
```

`@script`
In the next part of this lesson, you will have the opportunity to think through scenarios to determine which column type to use based on the data which you would like to represent in your database.
