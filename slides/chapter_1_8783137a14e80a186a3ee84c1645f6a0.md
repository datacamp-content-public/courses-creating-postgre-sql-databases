---
title: 'Insert title here'
key: 8783137a14e80a186a3ee84c1645f6a0
---

## Defining Numeric Data Columns

```yaml
type: TitleSlide
key: 3f4446f569
```

`@lower_third`
name: Darryl Reeves
title: Assistant Professor, Long Island University - Brooklyn

`@script`
Now that we have seen how to represent text data in our database, let's move on to the representation of numeric data.

---

## Numeric data with discrete values

```yaml
type: TwoRows
key: 1b35274c09
disable_transition: true
```

`@part1`
```
CREATE TABLE people.employee {
    id serial PRIMARY KEY,
    first_name varchar(50) NOT NULL,
    last_name varchar(50) NOT NULL
} {{1}}
```

`@part2`


`@script`
Imagine we are creating a database for a local retail clothing store. In such a scenario, we will likely be interested in having a representation for the store's employees. We can store details about the store's employees in a table named "employee". And this table will be part of the "people" schema. This schema may also include details about customers in a customer table which we will not define in this lesson.

The table has existing columns that have data types we are familiar with (namely a primary key and varchar columns to represent the employee's fullname)

---

## Numeric data with discrete values

```yaml
type: TwoRows
key: e3c847c81d
```

`@part1`
```
CREATE TABLE people.employee {
    id serial PRIMARY KEY,
    first_name varchar(50) NOT NULL,
    last_name varchar(50) NOT NULL,
    num_sales integer NULL
}
```

`@part2`


`@script`
One piece of information that we may want to track for store employees is how many sales for which the employee is responsible. This can be done by including a "num underscore sales" column when creating the employee table. We specify this column to contain NULL values in the case that we have an employee whose job does not involve sales such as an inventory manager. The explicit specification of NULL is unnecessary as this is the default setting for table columns. We choose to represent an employees number of sales as an integer because a sale is a discrete event. We do not anticipate awarding employee's with half of a sale or 3/4ths of a sale.

---

## Integer Types

```yaml
type: FullSlide
key: 8a408c6e2f
disable_transition: true
code_zoom: 106
```

`@part1`
| Type | Description | Range |
|---|--------------|---------|
| smallint | small-range integer | -32768 to +32767| {{1}}

`@script`
While we chose the integer type in the previous example, there are other options for representing discrete numerical values in PostgreSQL. For discrete numerical values that are expected to only exist in a small range, the smallint type can be used. Notice the minimum and maximum values for this type. This is a good type to use if a column won't need to need to represent large positive or negative discrete values. For instance, if we wanted to store someone's age in whole numbers, a smallint type would suffice.

---

## Integer Types

```yaml
type: FullSlide
key: 3d6ea79ad2
disable_transition: true
```

`@part1`
| Type | Description | Range |
|---|--------------|---------|
| smallint | small-range integer | -32768 to +32767|
| integer | typical choice for integer | -2147483648 to +2147483647         |

`@script`
In our employee table, we used the integer type to represent the number of sales. Based on the range of values allowed for this data type, we may have been better off using a smallint as the data type for this column. However, if we wanted to represent the population count of a large city, the integer type would be appropriate.

---

## Integer Types

```yaml
type: FullSlide
key: 38250b57d5
disable_transition: true
```

`@part1`
| Type | Description | Range |
|---|--------------|---------|
| smallint | small-range integer | -32768 to +32767|
| integer | typical choice for integer | -2147483648 to +2147483647         |
| bigint | large-range integer |-9223372036854775808 to 9223372036854775807         |

`@script`
For very large integer values, the bigint type is available. Given the large range of values that are allowed for this type, we can imagine using this type to represent a quantity such as the number of credit card transactions processed in a year for VISA or MasterCard.

---

## Integer Types

```yaml
type: FullSlide
key: 2e064a254e
disable_transition: false
```

`@part1`
| Type | Description | Range |
|---|--------------|---------|
| smallint | small-range integer | -32768 to +32767|
| integer | typical choice for integer | -2147483648 to +2147483647         |
| bigint | large-range integer |-9223372036854775808 to 9223372036854775807         |
| serial | autoincrementing integer | 1 to 2147483647 |

`@script`
Serial is a positive integer type that increments by one each time a new record is added to a table. This makes it a good choice for representing primary keys.

---

## Integer Types

```yaml
type: FullSlide
key: 2c9b265cb6
```

`@part1`
| Type | Description | Range |
|---|--------------|---------|
| bigserial | large autoincrementing integer | 1 to 9223372036854775807 |

`@script`
Finally, the bigserial type has the same properties as the serial type but allows a larger range of values. This would be a good choice for a table tracking NYC subway trips in a given year.

---

## Numeric data with continuous values

```yaml
type: TwoRows
key: 109e2b1f59
disable_transition: true
```

`@part1`
```
CREATE TABLE people.employee {
    id serial PRIMARY KEY,
    first_name varchar(50) NOT NULL,
    last_name varchar(50) NOT NULL,
    num_sales integer NULL
}
``` {{1}}

`@part2`


`@script`
PostgreSQL database tables are not confined to representing only discrete valued numeric types. Floating-point (aka decimal valued) columns are available to use. Let's revisit the employee table from earlier in this lesson. 

---

## Numeric data with continuous values

```yaml
type: TwoRows
key: 30c120cc9c
```

`@part1`
```
CREATE TABLE people.employee {
    id serial PRIMARY KEY,
    first_name varchar(50) NOT NULL,
    last_name varchar(50) NOT NULL,
    num_sales integer NULL,
    salary decimal(6,2) NOT NULL
}
``` {{1}}

`@part2`
*decimal(**precision**, **scale**)* {{2}}

`@script`
Imagine we would also like to track the salary of each employee. We can use the decimal type to represent salary data in our table. 

The decimal type can take two arguments: precision and scale. Precision is the number of digits to the left of the decimal point. Scale is the number of digits to the right of the decimal point. Here we are limiting 6 digits of precision for salary data and 2 digits of scale which should meet our needs for tracking employee salaries. Let's assume we won't have anyone making $1 million or more at our small shop. 

---

## Floating-point Types

```yaml
type: FullSlide
key: b844039e49
disable_transition: true
```

`@part1`
| Type | Description | Range |
|---|--------------|---------|
| decimal (numeric) | user-specified precision | up to 131072 digits before the decimal point; up to 16383 digits after the decimal point |

`@script`
The decimal and numeric types are interchangeable in PostgreSQL. They allow for a wide-range of floating-point values to be stored in a table as can be seen based on the range description.

---

## Floating-point Types

```yaml
type: FullSlide
key: 99452923ec
disable_transition: true
```

`@part1`
| Type | Description | Range |
|---|--------------|---------|
| decimal (numeric) | user-specified precision | up to 131072 digits before the decimal point; up to 16383 digits after the decimal point |
| real | variable-precision | 6 decimal digits precision |

`@script`
Two other floating-point types are available in PostgreSQL. They are the real type which guarantees 6 decimals of to be stored left of the decimal place.

---

## Floating-point Types

```yaml
type: FullSlide
key: a4c22ba7c7
```

`@part1`
| Type | Description | Range |
|---|--------------|---------|
| decimal (numeric) | user-specified precision | up to 131072 digits before the decimal point; up to 16383 digits after the decimal point |
| real | variable-precision | 6 decimal digits precision |
| double precision | variable-precision | 15 decimal digits precision |

`@script`


---

## Let's practice!

```yaml
type: FinalSlide
key: 6e8f830bb9
```

`@script`
In the next part of this lesson, you will have the opportunity to think through scenarios to determine which column type to use based on the data which you would like to represent in your database. Let's practice!
