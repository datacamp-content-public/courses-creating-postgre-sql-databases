---
title: 'Insert title here'
key: 8783137a14e80a186a3ee84c1645f6a0
---

## Defining Numeric Data Columns

```yaml
type: TitleSlide
key: 3f4446f569
```

`@lower_third`
name: Darryl Reeves
title: Assistant Professor, Long Island University - Brooklyn

`@script`
Now that we have seen how to represent text data in our database, let's move on to the representation of numeric data.

---

## Numeric data with discrete values

```yaml
type: TwoRows
key: 1b35274c09
disable_transition: true
```

`@part1`
```
CREATE TABLE people.employee {
    id serial PRIMARY KEY,
    first_name varchar(50) NOT NULL,
    last_name varchar(50) NOT NULL
} {{1}}
```

`@part2`


`@script`
Imagine we are creating a database for a local retail clothing store. We will likely be interested in having a representation for the store's employees. We can store details about the store's employees in a table named "employee" as part of a "people" schema. 

A definition of the table is included here with some basic columns for the employees.

---

## Numeric data with discrete values

```yaml
type: TwoRows
key: e3c847c81d
```

`@part1`
```
CREATE TABLE people.employee {
    id serial PRIMARY KEY,
    first_name varchar(50) NOT NULL,
    last_name varchar(50) NOT NULL,
    num_sales integer
}
```

`@part2`


`@script`
What if we wanted to also track the number of sales generated by an employee. This can be done by including a "num underscore sales" column when creating the employee table. We do not anticipate anticipate awarding half of a sale to an employee so a discrete value is appropriate here.

---

## Integer Types

```yaml
type: FullSlide
key: 8a408c6e2f
disable_transition: true
code_zoom: 106
```

`@part1`
| Type | Description | Range |
|---|--------------|---------|
| smallint | small-range integer | -32768 to +32767| {{1}}

`@script`
PostgreSQL provides other options for representing discrete numerical values. The smallint type can be used for columns needing discrete values in a small range. This is a good type to use if a column only requires relatively small quantities. For instance, if we wanted to store someone's age in whole numbers, a smallint column would suffice.

---

## Integer Types

```yaml
type: FullSlide
key: 3d6ea79ad2
disable_transition: true
```

`@part1`
| Type | Description | Range |
|---|--------------|---------|
| smallint | small-range integer | -32768 to +32767|
| integer | typical choice for integer | -2147483648 to +2147483647         |

`@script`
In our employee table, we used the integer type to represent the number of sales. If we wanted to represent the population count of a large city, the integer type would be appropriate given the range of values it can represent.

---

## Integer Types

```yaml
type: FullSlide
key: 38250b57d5
disable_transition: true
```

`@part1`
| Type | Description | Range |
|---|--------------|---------|
| smallint | small-range integer | -32768 to +32767|
| integer | typical choice for integer | -2147483648 to +2147483647         |
| bigint | large-range integer |-9223372036854775808 to 9223372036854775807         |

`@script`
For columns requiring very large integer values, the bigint type is available. Given the large range of values that are allowed for this type, this type could be used to represent the number of credit card transactions processed in a year for VISA or MasterCard.

---

## Integer Types

```yaml
type: FullSlide
key: 2e064a254e
disable_transition: false
```

`@part1`
| Type | Description | Range |
|---|--------------|---------|
| smallint | small-range integer | -32768 to +32767|
| integer | typical choice for integer | -2147483648 to +2147483647         |
| bigint | large-range integer |-9223372036854775808 to 9223372036854775807         |
| serial | autoincrementing integer | 1 to 2147483647 |

`@script`
Serial is a positive integer type that increments by one each time a new record is added to a table. This makes it a good choice for representing primary keys.

---

## Integer Types

```yaml
type: FullSlide
key: 2c9b265cb6
```

`@part1`
| Type | Description | Range |
|---|--------------|---------|
| bigserial | large autoincrementing integer | 1 to 9223372036854775807 |

`@script`
Finally, the bigserial type has the same properties as the serial type but allows a larger range of values. This would be a good choice for a table tracking NYC subway trips in a given year.

---

## Numeric data with continuous values

```yaml
type: TwoRows
key: 109e2b1f59
disable_transition: true
```

`@part1`
```
CREATE TABLE people.employee {
    id serial PRIMARY KEY,
    first_name varchar(50) NOT NULL,
    last_name varchar(50) NOT NULL,
    num_sales integer NULL
}
``` {{1}}

`@part2`


`@script`
Floating-point (aka decimal valued) columns are also available in PostgreSQL. Let's revisit the employee table from earlier in this lesson.

---

## Numeric data with continuous values

```yaml
type: TwoRows
key: 30c120cc9c
```

`@part1`
```
CREATE TABLE people.employee {
    id serial PRIMARY KEY,
    first_name varchar(50) NOT NULL,
    last_name varchar(50) NOT NULL,
    num_sales integer NULL,
    salary decimal(6,2) NOT NULL
}
``` {{1}}

`@part2`
*decimal(**precision**, **scale**)* {{2}}

`@script`
Imagine we would also like to track the salary of each employee. We can use the decimal type to represent salary data in our table. 

The decimal type can take two arguments: precision and scale. Precision is the number of digits to the left of the decimal point. Scale is the number of digits to the right of the decimal point. Here we are limiting the column entries to 6 digits of precision for salary data and 2 digits of scale. This assumes we won't have anyone making $1 million or more at our small shop.

---

## Floating-point Types

```yaml
type: FullSlide
key: b844039e49
disable_transition: true
```

`@part1`
| Type | Description | Range |
|---|--------------|---------|
| decimal (numeric) | user-specified precision | up to 131072 digits before the decimal point; up to 16383 digits after the decimal point |

`@script`
The decimal and numeric types are interchangeable in PostgreSQL. They allow for a wide-range of floating-point values to be stored in a table as can be seen based on the range description.

---

## Floating-point Types

```yaml
type: FullSlide
key: 99452923ec
disable_transition: true
```

`@part1`
| Type | Description | Range |
|---|--------------|---------|
| decimal (numeric) | user-specified precision | up to 131072 digits before the decimal point; up to 16383 digits after the decimal point |
| real | variable-precision | 6 decimal digits precision |

`@script`
Two other floating-point types are available in PostgreSQL. They are the real type which guarantees 6 decimals of to be stored left of the decimal place.

---

## Floating-point Types

```yaml
type: FullSlide
key: a4c22ba7c7
```

`@part1`
| Type | Description | Range |
|---|--------------|---------|
| decimal (numeric) | user-specified precision | up to 131072 digits before the decimal point; up to 16383 digits after the decimal point |
| real | variable-precision | 6 decimal digits precision |
| double precision | variable-precision | 15 decimal digits precision |

`@script`
The double precision type is similar but allows up to 15 digits to the left of the decimal point. For both, the real and double precision types, the number of digits to the right of the decimal point is not guaranteed to have a specific number of digits.

---

## Let's practice!

```yaml
type: FinalSlide
key: 6e8f830bb9
```

`@script`
In the next part of this lesson, you will have the opportunity to think through scenarios to determine which column type to use based on the data which you would like to represent in your database.
